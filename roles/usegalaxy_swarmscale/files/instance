#!/usr/bin/env python
from __future__ import print_function

import argparse
import json
import math
import os
import shutil
import subprocess
import sys
import tempfile
import uuid


NODE_BASENAME = 'jetstream-iu-swarm'
SLOT_SIZE = 1.0
MAX_NODES = 8
CLOUD_ID = 'jetstream_iu'
# TODO: load balance
DOCKER_CMD = ['docker', '--host', 'tcp://jetstream-tacc0.galaxyproject.org:2376', '--tlsverify']


def get_node_names(nodect):
    inv = json.loads(run_cmd(['ansible-inventory', '--list'], output=True))
    hostvars = inv['_meta']['hostvars']
    names = []
    for i in range(0, MAX_NODES):
        if len(names) == nodect:
            break
        host = NODE_BASEAME + str(i)
        state = hostvars.get(host, {}).get('status', 'NOT_EXIST')
        print('host: %s, state: %s' % (host, state))
        if state in ('NOT_EXIST', 'SHUTOFF'):
            names.append(host)
    else:
        print('WARNING: not enough nodes available for %s nodes, raise MAX_NODES? Returning: %s' % (nodect, names))
    return names


def get_worker_join_token:
    return run_cmd(DOCKER_CMD + ['swarm', 'join-token', '--quiet', 'worker'], output=True).strip()


def create_inventory(node_names):
    inventory = tempfile.NamedTemporaryFile(prefix='spawn.%s.' % os.getpid(), dir=os.path.join(os.getcwd(), 'inventory'))
    join_token = get_worker_join_token()
    inventory.write('[all:vars]\n')
    inventory.write('swarm_worker_join_token = %s\n' % join_token)
    inventory.write('[swarmnodes]\n')
    for name in node_names:
        inventory.write(name)
        inventory.write('\n')
    inventory.flush()
    return inventory


def get_env():
    env = os.environ.copy()
    env['PATH'] = '{venv_bin}:{path}'.format(
        venv_bin=os.path.abspath('../../bin'),
        path=os.environ['PATH']
    )
    return env


def run_cmd(cmd, output=False):
    print('Running %s' % ' '.join(cmd), file=sys.stderr)
    if output:
        subprocess.check_output(cmd, env=get_env())
    else:
        subprocess.check_call(cmd, stdout=sys.stderr, env=get_env())


def run_playbook(playbook, args=None):
    if not args:
        args = []
    cmd = ['ansible-playbook', playbook] + args
    run_cmd(cmd)


def spawn(slots):
    nodes_needed = int(math.ceil(slots * SLOT_SIZE))
    print('Need %s nodes' % nodes_needed, file=sys.stderr)
    node_names = gen_node_names(nodes_needed)
    inventory = create_inventory(node_names)
    limit_arg = ':'.join(node_names)
    try:
        run_playbook('spawn.yml', inventory.name, args=['--limit', limit_arg])
    except subprocess.CalledProcessError as exc:
        # indicate that spawning sohuld be retried
        print("WARNING: spawn failed with code %s\n" % exc.returncode, file=sys.stderr)
        sys.exit(2)
    finally:
        inventory.close()
    print(' '.join(node_names))


def destroy(nodes):
    limit_arg = ':'.join(nodes)
    try:
        run_playbook('suspend.yml', args=['--limit', limit_arg])
    except subprocess.CalledProcessError as exc:
        print("WARNING: `docker swarm leave` or instance suspend failed with code %s\n" % exc.returncode, file=sys.stderr)
    try:
        cmd = DOCKER_CMD + ['node', 'rm'] + nodes
        run_cmd(cmd)
    except subprocess.CalledProcessError as exc:
        print("WARNING: `docker node rm` failed with code %s\n" % exc.returncode, file=sys.stderr)
    cmd = DOCKER_CMD + ['node', 'rm', '-f'] + nodes
    run_cmd(cmd)
    print(' '.join(nodes))


def get_args():
    parser = argparse.ArgumentParser(description='Spawn or Destroy swarm nodes')
    parser.add_argument('--slots', type=int, default=0, help='Number of slots needed')
    parser.add_argument('--destroy', action='store_true', default=False, help='Destroy nodes')
    parser.add_argument('nodes', metavar='NODE', nargs='*', help='Nodes to destroy')
    args = parser.parse_args()
    return args


def handle_args():
    args = get_args()
    if args.slots:
        spawn(args.slots)
    elif args.nodes and args.destroy:
        destroy(args.nodes)
    else:
        print('nothing to do')


if __name__ == '__main__':
    os.chdir(os.path.abspath(os.path.dirname(__file__)))
    handle_args()
